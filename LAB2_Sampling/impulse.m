function [t, p] = impulse(t1, t2, N, fs)

t_p = 1 / fs; % 주기
s = fs * (t2 - t1);
% 시작값과 종료값까지의 범위 중 주파수가 f일때 1인 임펄스값을 갖는 t의 개수
h = ceil(N / s);
% 1의 값을 갖는 앞의 t와 뒤의 t의 폭을 구하기 위해 총길이를 s와 나눔
% 이 때, 폭이 소수점이 나오는 것을 방지해 ceil()를 사용해 반올림
% 폭이 소수점이 나오는 것을 방지하는 이유는 0이 나오는 t의 값의 갯수가 
% 소수일 수 없기 때문임
% N/s가 소수라면, 값을 올림으로써 0이 되어야 하는 칸이 늘어나야 한다.

p_p = zeros(1, h); % p의 한 주기, p의 하나의 폭만큼의 크기를 가짐
t = zeros(1, N); % 출력 시간은 임펄스열의 전체 길이만큼 나옴

for i=1:1:N % N의 길이만큼 연산 수행
    t(i) = t1; % t1부터 연산 수행
    t1 = t1 + (t_p/h); % 한칸당 주기 / 한주기에 들어가야하는 칸의 개수 값을 가짐
end
N0 = fix(N/h); % p의 길이를 N과 맞춤
N1 = mod(N, h); % 나머지를 p에 붙여주기 위함
p_p(1) = 1; % 시작을 1로 잡음
p0 = repmat(p_p, 1, N0); % 만들어진 주기신호 p_p를 N0만큼 복사
p1 = zeros(1, N1); % 나머지 h만큼의 폭을 가지지 못한 N1만큼은 0으로 처리
p = [p0 p1];